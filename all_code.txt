================================================================================
COMPLETE HELM CHART CODE FOR KUBERNETES APPLICATION DEPLOYMENT
================================================================================

This file contains all the code for a complete Helm chart that deploys a 
Node.js application to Kubernetes with AWS EKS integration, including:
- GitHub Actions CI/CD pipeline
- AWS ECR integration
- Application Load Balancer (ALB) ingress
- Auto-scaling, monitoring, and production-ready configurations

================================================================================
1. HELM CHART METADATA
================================================================================

# helm/my-app/Chart.yaml
apiVersion: v2
name: my-app
description: A Helm chart for deploying my application to Kubernetes
type: application
version: 0.1.0
appVersion: "1.0.0"
keywords:
  - web
  - application
  - microservice
home: https://github.com/your-org/my-app
sources:
  - https://github.com/your-org/my-app
maintainers:
  - name: Your Name
    email: your.email@company.com
annotations:
  category: Application

================================================================================
2. HELM TEMPLATE HELPERS
================================================================================

# helm/my-app/templates/_helpers.tpl
{{/*
Expand the name of the chart.
*/}}
{{- define "my-app.name" -}}
{{- default .Chart.Name .Values.nameOverride | trunc 63 | trimSuffix "-" }}
{{- end }}

{{/*
Create a default fully qualified app name.
We truncate at 63 chars because some Kubernetes name fields are limited to this (by the DNS naming spec).
If release name contains chart name it will be used as a full name.
*/}}
{{- define "my-app.fullname" -}}
{{- if .Values.fullnameOverride }}
{{- .Values.fullnameOverride | trunc 63 | trimSuffix "-" }}
{{- else }}
{{- $name := default .Chart.Name .Values.nameOverride }}
{{- if contains $name .Release.Name }}
{{- .Release.Name | trunc 63 | trimSuffix "-" }}
{{- else }}
{{- printf "%s-%s" .Release.Name $name | trunc 63 | trimSuffix "-" }}
{{- end }}
{{- end }}
{{- end }}

{{/*
Create chart name and version as used by the chart label.
*/}}
{{- define "my-app.chart" -}}
{{- printf "%s-%s" .Chart.Name .Chart.Version | replace "+" "_" | trunc 63 | trimSuffix "-" }}
{{- end }}

{{/*
Common labels
*/}}
{{- define "my-app.labels" -}}
helm.sh/chart: {{ include "my-app.chart" . }}
{{ include "my-app.selectorLabels" . }}
{{- if .Chart.AppVersion }}
app.kubernetes.io/version: {{ .Chart.AppVersion | quote }}
{{- end }}
app.kubernetes.io/managed-by: {{ .Release.Service }}
{{- end }}

{{/*
Selector labels
*/}}
{{- define "my-app.selectorLabels" -}}
app.kubernetes.io/name: {{ include "my-app.name" . }}
app.kubernetes.io/instance: {{ .Release.Name }}
{{- end }}

{{/*
Create the name of the service account to use
*/}}
{{- define "my-app.serviceAccountName" -}}
{{- if .Values.serviceAccount.create }}
{{- default (include "my-app.fullname" .) .Values.serviceAccount.name }}
{{- else }}
{{- default "default" .Values.serviceAccount.name }}
{{- end }}
{{- end }}

{{/*
Create the image name
*/}}
{{- define "my-app.image" -}}
{{- if .Values.global.imageRegistry }}
{{- printf "%s/%s:%s" .Values.global.imageRegistry .Values.image.repository (.Values.image.tag | default .Chart.AppVersion) }}
{{- else }}
{{- printf "%s/%s:%s" .Values.image.registry .Values.image.repository (.Values.image.tag | default .Chart.AppVersion) }}
{{- end }}
{{- end }}

{{/*
Create configmap name
*/}}
{{- define "my-app.configMapName" -}}
{{- if .Values.envFrom.configMapRef.name }}
{{- .Values.envFrom.configMapRef.name }}
{{- else }}
{{- include "my-app.fullname" . }}
{{- end }}
{{- end }}

{{/*
Create secret name
*/}}
{{- define "my-app.secretName" -}}
{{- if .Values.envFrom.secretRef.name }}
{{- .Values.envFrom.secretRef.name }}
{{- else }}
{{- include "my-app.fullname" . }}
{{- end }}
{{- end }}

================================================================================
3. KUBERNETES DEPLOYMENT
================================================================================

# helm/my-app/templates/deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: {{ include "my-app.fullname" . }}
  labels:
    {{- include "my-app.labels" . | nindent 4 }}
spec:
  {{- if not .Values.autoscaling.enabled }}
  replicas: {{ .Values.replicaCount }}
  {{- end }}
  selector:
    matchLabels:
      {{- include "my-app.selectorLabels" . | nindent 6 }}
  template:
    metadata:
      annotations:
        checksum/config: {{ include (print $.Template.BasePath "/configmap.yaml") . | sha256sum }}
        checksum/secret: {{ include (print $.Template.BasePath "/secret.yaml") . | sha256sum }}
        {{- with .Values.podAnnotations }}
        {{- toYaml . | nindent 8 }}
        {{- end }}
      labels:
        {{- include "my-app.selectorLabels" . | nindent 8 }}
        {{- with .Values.podLabels }}
        {{- toYaml . | nindent 8 }}
        {{- end }}
    spec:
      {{- with .Values.image.pullSecrets }}
      imagePullSecrets:
        {{- toYaml . | nindent 8 }}
      {{- end }}
      serviceAccountName: {{ include "my-app.serviceAccountName" . }}
      securityContext:
        {{- toYaml .Values.podSecurityContext | nindent 8 }}
      {{- with .Values.initContainers }}
      initContainers:
        {{- toYaml . | nindent 8 }}
      {{- end }}
      containers:
        - name: {{ .Values.container.name }}
          securityContext:
            {{- toYaml .Values.securityContext | nindent 12 }}
          image: {{ include "my-app.image" . }}
          imagePullPolicy: {{ .Values.image.pullPolicy }}
          ports:
            - name: http
              containerPort: {{ .Values.container.port }}
              protocol: TCP
          {{- if .Values.livenessProbe.enabled }}
          livenessProbe:
            {{- omit .Values.livenessProbe "enabled" | toYaml | nindent 12 }}
          {{- end }}
          {{- if .Values.readinessProbe.enabled }}
          readinessProbe:
            {{- omit .Values.readinessProbe "enabled" | toYaml | nindent 12 }}
          {{- end }}
          resources:
            {{- toYaml .Values.resources | nindent 12 }}
          env:
            {{- toYaml .Values.env | nindent 12 }}
          {{- if or .Values.configMap.enabled .Values.secret.enabled }}
          envFrom:
            {{- if .Values.configMap.enabled }}
            - configMapRef:
                name: {{ include "my-app.configMapName" . }}
            {{- end }}
            {{- if .Values.secret.enabled }}
            - secretRef:
                name: {{ include "my-app.secretName" . }}
            {{- end }}
          {{- end }}
          volumeMounts:
            {{- if .Values.persistence.enabled }}
            - name: data
              mountPath: {{ .Values.persistence.mountPath }}
            {{- end }}
            {{- with .Values.extraVolumeMounts }}
            {{- toYaml . | nindent 12 }}
            {{- end }}
        {{- with .Values.sidecars }}
        {{- toYaml . | nindent 8 }}
        {{- end }}
      volumes:
        {{- if .Values.persistence.enabled }}
        - name: data
          persistentVolumeClaim:
            claimName: {{ include "my-app.fullname" . }}
        {{- end }}
        {{- with .Values.extraVolumes }}
        {{- toYaml . | nindent 8 }}
        {{- end }}
      {{- with .Values.nodeSelector }}
      nodeSelector:
        {{- toYaml . | nindent 8 }}
      {{- end }}
      {{- with .Values.affinity }}
      affinity:
        {{- toYaml . | nindent 8 }}
      {{- end }}
      {{- with .Values.tolerations }}
      tolerations:
        {{- toYaml . | nindent 8 }}
      {{- end }}

================================================================================
4. KUBERNETES SERVICE
================================================================================

# helm/my-app/templates/service.yaml
apiVersion: v1
kind: Service
metadata:
  name: {{ include "my-app.fullname" . }}
  labels:
    {{- include "my-app.labels" . | nindent 4 }}
  {{- with .Values.service.annotations }}
  annotations:
    {{- toYaml . | nindent 4 }}
  {{- end }}
spec:
  type: {{ .Values.service.type }}
  ports:
    - port: {{ .Values.service.port }}
      targetPort: {{ .Values.service.targetPort }}
      protocol: TCP
      name: http
  selector:
    {{- include "my-app.selectorLabels" . | nindent 4 }}

================================================================================
5. KUBERNETES INGRESS (AWS ALB)
================================================================================

# helm/my-app/templates/ingress.yaml
{{- if .Values.ingress.enabled -}}
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: {{ include "my-app.fullname" . }}
  labels:
    {{- include "my-app.labels" . | nindent 4 }}
  {{- with .Values.ingress.annotations }}
  annotations:
    {{- toYaml . | nindent 4 }}
  {{- end }}
spec:
  {{- if .Values.ingress.className }}
  ingressClassName: {{ .Values.ingress.className }}
  {{- end }}
  {{- if .Values.ingress.tls }}
  tls:
    {{- range .Values.ingress.tls }}
    - hosts:
        {{- range .hosts }}
        - {{ . | quote }}
        {{- end }}
      secretName: {{ .secretName }}
    {{- end }}
  {{- end }}

================================================================================
6. CONFIGMAP AND SECRET
================================================================================

# helm/my-app/templates/configmap.yaml
{{- if .Values.configMap.enabled }}
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ include "my-app.configMapName" . }}
  labels:
    {{- include "my-app.labels" . | nindent 4 }}
data:
  {{- with .Values.configMap.data }}
  {{- toYaml . | nindent 2 }}
  {{- end }}
{{- end }}

# helm/my-app/templates/secret.yaml
{{- if .Values.secret.enabled }}
apiVersion: v1
kind: Secret
metadata:
  name: {{ include "my-app.secretName" . }}
  labels:
    {{- include "my-app.labels" . | nindent 4 }}
type: Opaque
data:
  {{- with .Values.secret.data }}
  {{- toYaml . | nindent 2 }}
  {{- end }}
{{- end }}

================================================================================
7. SERVICE ACCOUNT
================================================================================

# helm/my-app/templates/serviceaccount.yaml
{{- if .Values.serviceAccount.create -}}
apiVersion: v1
kind: ServiceAccount
metadata:
  name: {{ include "my-app.serviceAccountName" . }}
  labels:
    {{- include "my-app.labels" . | nindent 4 }}
  {{- with .Values.serviceAccount.annotations }}
  annotations:
    {{- toYaml . | nindent 4 }}
  {{- end }}
automountServiceAccountToken: true
{{- end }}

================================================================================
8. HORIZONTAL POD AUTOSCALER
================================================================================

# helm/my-app/templates/hpa.yaml
{{- if .Values.autoscaling.enabled }}
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: {{ include "my-app.fullname" . }}
  labels:
    {{- include "my-app.labels" . | nindent 4 }}
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: {{ include "my-app.fullname" . }}
  minReplicas: {{ .Values.autoscaling.minReplicas }}
  maxReplicas: {{ .Values.autoscaling.maxReplicas }}
  metrics:
    {{- if .Values.autoscaling.targetCPUUtilizationPercentage }}
    - type: Resource
      resource:
        name: cpu
        target:
          type: Utilization
          averageUtilization: {{ .Values.autoscaling.targetCPUUtilizationPercentage }}
    {{- end }}
    {{- if .Values.autoscaling.targetMemoryUtilizationPercentage }}
    - type: Resource
      resource:
        name: memory
        target:
          type: Utilization
          averageUtilization: {{ .Values.autoscaling.targetMemoryUtilizationPercentage }}
    {{- end }}
{{- end }}

================================================================================
9. POD DISRUPTION BUDGET
================================================================================

# helm/my-app/templates/pdb.yaml
{{- if .Values.podDisruptionBudget.enabled }}
apiVersion: policy/v1
kind: PodDisruptionBudget
metadata:
  name: {{ include "my-app.fullname" . }}
  labels:
    {{- include "my-app.labels" . | nindent 4 }}
spec:
  {{- if .Values.podDisruptionBudget.minAvailable }}
  minAvailable: {{ .Values.podDisruptionBudget.minAvailable }}
  {{- end }}
  {{- if .Values.podDisruptionBudget.maxUnavailable }}
  maxUnavailable: {{ .Values.podDisruptionBudget.maxUnavailable }}
  {{- end }}
  selector:
    matchLabels:
      {{- include "my-app.selectorLabels" . | nindent 6 }}
{{- end }}

================================================================================
10. PERSISTENT VOLUME CLAIM
================================================================================

# helm/my-app/templates/pvc.yaml
{{- if .Values.persistence.enabled }}
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: {{ include "my-app.fullname" . }}
  labels:
    {{- include "my-app.labels" . | nindent 4 }}
spec:
  accessModes:
    - {{ .Values.persistence.accessMode }}
  resources:
    requests:
      storage: {{ .Values.persistence.size }}
  {{- if .Values.persistence.storageClass }}
  storageClassName: {{ .Values.persistence.storageClass }}
  {{- end }}
{{- end }}

================================================================================
11. NETWORK POLICY
================================================================================

# helm/my-app/templates/networkpolicy.yaml
{{- if .Values.networkPolicy.enabled }}
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: {{ include "my-app.fullname" . }}
  labels:
    {{- include "my-app.labels" . | nindent 4 }}
spec:
  podSelector:
    matchLabels:
      {{- include "my-app.selectorLabels" . | nindent 6 }}
  policyTypes:
    {{- range .Values.networkPolicy.policyTypes }}
    - {{ . }}
    {{- end }}
  {{- if .Values.networkPolicy.ingress }}
  ingress:
    {{- toYaml .Values.networkPolicy.ingress | nindent 4 }}
  {{- end }}
  {{- if .Values.networkPolicy.egress }}
  egress:
    {{- toYaml .Values.networkPolicy.egress | nindent 4 }}
  {{- end }}
{{- end }}

================================================================================
12. HELM NOTES (POST-INSTALL INSTRUCTIONS)
================================================================================

# helm/my-app/templates/NOTES.txt
1. Get the application URL by running these commands:
{{- if .Values.ingress.enabled }}
{{- range $host := .Values.ingress.hosts }}
  {{- range .paths }}
  http{{ if $.Values.ingress.tls }}s{{ end }}://{{ $host.host }}{{ .path }}
  {{- end }}
{{- end }}
{{- else if contains "NodePort" .Values.service.type }}
  export NODE_PORT=$(kubectl get --namespace {{ .Release.Namespace }} -o jsonpath="{.spec.ports[0].nodePort}" services {{ include "my-app.fullname" . }})
  export NODE_IP=$(kubectl get nodes --namespace {{ .Release.Namespace }} -o jsonpath="{.items[0].status.addresses[0].address}")
  echo http://$NODE_IP:$NODE_PORT
{{- else if contains "LoadBalancer" .Values.service.type }}
     NOTE: It may take a few minutes for the LoadBalancer IP to be available.
           You can watch the status of by running 'kubectl get --namespace {{ .Release.Namespace }} svc -w {{ include "my-app.fullname" . }}'
  export SERVICE_IP=$(kubectl get svc --namespace {{ .Release.Namespace }} {{ include "my-app.fullname" . }} --template "{{"{{ range (index .status.loadBalancer.ingress 0) }}{{.}}{{ end }}"}}")
  echo http://$SERVICE_IP:{{ .Values.service.port }}
{{- else if contains "ClusterIP" .Values.service.type }}
  export POD_NAME=$(kubectl get pods --namespace {{ .Release.Namespace }} -l "app.kubernetes.io/name={{ include "my-app.name" . }},app.kubernetes.io/instance={{ .Release.Name }}" -o jsonpath="{.items[0].metadata.name}")
  export CONTAINER_PORT=$(kubectl get pod --namespace {{ .Release.Namespace }} $POD_NAME -o jsonpath="{.spec.containers[0].ports[0].containerPort}")
  echo "Visit http://127.0.0.1:8080 to use your application"
  kubectl --namespace {{ .Release.Namespace }} port-forward $POD_NAME 8080:$CONTAINER_PORT
{{- end }}

2. Check the status of your deployment:
   kubectl get pods -l "app.kubernetes.io/name={{ include "my-app.name" . }},app.kubernetes.io/instance={{ .Release.Name }}" -n {{ .Release.Namespace }}

3. View application logs:
   kubectl logs -l "app.kubernetes.io/name={{ include "my-app.name" . }},app.kubernetes.io/instance={{ .Release.Name }}" -n {{ .Release.Namespace }}

4. Scale your application:
   kubectl scale deployment {{ include "my-app.fullname" . }} --replicas=3 -n {{ .Release.Namespace }}

{{- if .Values.autoscaling.enabled }}
5. Monitor auto-scaling:
   kubectl get hpa {{ include "my-app.fullname" . }} -n {{ .Release.Namespace }}
{{- end }}

{{- if .Values.persistence.enabled }}
6. Check persistent volume:
   kubectl get pvc {{ include "my-app.fullname" . }} -n {{ .Release.Namespace }}
{{- end }}

================================================================================
13. DEFAULT VALUES CONFIGURATION
================================================================================

# helm/my-app/values.yaml
# Default values for my-app
# This is a YAML-formatted file.

# Global settings
global:
  imageRegistry: ""
  imagePullSecrets: []

# Application configuration
app:
  name: my-app
  version: "1.0.0"

# Image configuration
image:
  registry: "992878410375.dkr.ecr.ap-south-1.amazonaws.com"
  repository: "code_dev"
  tag: "latest"
  pullPolicy: IfNotPresent
  pullSecrets: []

# Deployment configuration
replicaCount: 2

# Container configuration
container:
  port: 3000
  name: code-dev-app

# Environment variables
env:
  - name: NODE_ENV
    value: "production"
  - name: PORT
    value: "3000"
  - name: LOG_LEVEL
    value: "info"

# Environment variables from ConfigMap
envFrom:
  configMapRef:
    name: ""  # Will use app name if empty
  secretRef:
    name: ""  # Will use app name if empty

# Resource limits and requests
resources:
  limits:
    cpu: 500m
    memory: 512Mi
  requests:
    cpu: 250m
    memory: 256Mi

# Liveness and readiness probes
livenessProbe:
  enabled: true
  httpGet:
    path: /
    port: http
  initialDelaySeconds: 30
  periodSeconds: 10
  timeoutSeconds: 5
  failureThreshold: 3
  successThreshold: 1

readinessProbe:
  enabled: true
  httpGet:
    path: /
    port: http
  initialDelaySeconds: 5
  periodSeconds: 5
  timeoutSeconds: 3
  failureThreshold: 3
  successThreshold: 1

# Service configuration
service:
  type: ClusterIP
  port: 80
  targetPort: 3000
  annotations: {}

# Ingress configuration
ingress:
  enabled: true
  className: "alb"
  annotations:
    kubernetes.io/ingress.class: alb
    alb.ingress.kubernetes.io/scheme: internet-facing
    alb.ingress.kubernetes.io/target-type: ip
    alb.ingress.kubernetes.io/listen-ports: '[{"HTTP": 80}]'
    # SSL/HTTPS disabled - using HTTP only
    # alb.ingress.kubernetes.io/certificate-arn: ""  # Add your ACM certificate ARN for HTTPS
  hosts:
    - paths:
        - path: /
          pathType: Prefix
  tls: []

# Horizontal Pod Autoscaler
autoscaling:
  enabled: true
  minReplicas: 2
  maxReplicas: 10
  targetCPUUtilizationPercentage: 70
  targetMemoryUtilizationPercentage: 80

# Pod Disruption Budget
podDisruptionBudget:
  enabled: true
  minAvailable: 1

# Security Context
securityContext:
  runAsNonRoot: true
  runAsUser: 1000
  runAsGroup: 3000

# Pod Security Context
podSecurityContext:
  fsGroup: 2000

# Node selector
nodeSelector: {}

# Tolerations
tolerations: []

# Affinity
affinity: {}

# Pod annotations
podAnnotations: {}

# Pod labels
podLabels: {}

# Service Account
serviceAccount:
  create: true
  annotations: {}
  name: ""

# ConfigMap data
configMap:
  enabled: true
  data:
    app.properties: |
      # Application configuration
      server.port=8080
      logging.level.root=INFO
      management.endpoints.web.exposure.include=health,info,metrics

# Secret data (base64 encoded values)
secret:
  enabled: true
  data: {}
    # database-password: "cGFzc3dvcmQ="  # base64 encoded password

# Persistent Volume Claim
persistence:
  enabled: false
  storageClass: "gp2"
  accessMode: ReadWriteOnce
  size: 8Gi
  mountPath: /data

# Init containers
initContainers: []

# Sidecar containers
sidecars: []

# Extra volumes
extraVolumes: []

# Extra volume mounts
extraVolumeMounts: []

# Network Policy
networkPolicy:
  enabled: false
  policyTypes:
    - Ingress
    - Egress
  ingress: []
  egress: []

================================================================================
14. DEVELOPMENT ENVIRONMENT VALUES
================================================================================

# helm/my-app/values-dev.yaml
# Development environment values
# Override values for development environment

# Image configuration for development
image:
  registry: "992878410375.dkr.ecr.ap-south-1.amazonaws.com"
  repository: "code_dev"
  tag: "latest"
  pullPolicy: Always

# Reduced resources for development
replicaCount: 1

resources:
  limits:
    cpu: 200m
    memory: 256Mi
  requests:
    cpu: 100m
    memory: 128Mi

# Development environment variables
env:
  - name: NODE_ENV
    value: "development"
  - name: PORT
    value: "3000"
  - name: LOG_LEVEL
    value: "debug"
  - name: DEBUG
    value: "true"
  - name: VITE_ENV
    value: "development"

# Disable autoscaling in development
autoscaling:
  enabled: false

# Development ingress configuration
ingress:
  enabled: true
  className: "alb"
  annotations:
    kubernetes.io/ingress.class: alb
    alb.ingress.kubernetes.io/scheme: internet-facing
    alb.ingress.kubernetes.io/target-type: ip
    alb.ingress.kubernetes.io/listen-ports: '[{"HTTP": 80}]'
  hosts:
    - paths:
        - path: /
          pathType: Prefix

# Development ConfigMap
configMap:
  enabled: true
  data:
    app.properties: |
      # Development configuration
      server.port=8080
      logging.level.root=DEBUG
      management.endpoints.web.exposure.include=health,info,metrics,env
      spring.profiles.active=development

# Disable persistence in development
persistence:
  enabled: false

# Relaxed probes for development
livenessProbe:
  enabled: true
  httpGet:
    path: /health
    port: http
  initialDelaySeconds: 60
  periodSeconds: 30
  timeoutSeconds: 10
  failureThreshold: 5

readinessProbe:
  enabled: true
  httpGet:
    path: /ready
    port: http
  initialDelaySeconds: 10
  periodSeconds: 10
  timeoutSeconds: 5
  failureThreshold: 5

================================================================================
15. PRODUCTION ENVIRONMENT VALUES
================================================================================

# helm/my-app/values-prod.yaml
# Production environment values
# Override values for production environment

# Image configuration for production
image:
  registry: "992878410375.dkr.ecr.ap-south-1.amazonaws.com"
  repository: "code_dev"
  tag: "latest"  # Use specific version tags in production
  pullPolicy: IfNotPresent

# Production scaling
replicaCount: 3

# Production resources
resources:
  limits:
    cpu: 1000m
    memory: 1Gi
  requests:
    cpu: 500m
    memory: 512Mi

# Production environment variables
env:
  - name: NODE_ENV
    value: "production"
  - name: PORT
    value: "3000"
  - name: LOG_LEVEL
    value: "info"
  - name: VITE_ENV
    value: "production"

# Enable autoscaling in production
autoscaling:
  enabled: true
  minReplicas: 3
  maxReplicas: 20
  targetCPUUtilizationPercentage: 70
  targetMemoryUtilizationPercentage: 80

# Production ingress with SSL
ingress:
  enabled: true
  className: "alb"
  annotations:
    kubernetes.io/ingress.class: alb
    alb.ingress.kubernetes.io/scheme: internet-facing
    alb.ingress.kubernetes.io/target-type: ip
    alb.ingress.kubernetes.io/listen-ports: '[{"HTTP": 80}]'
    # SSL disabled - using HTTP only (add SSL cert later if needed)
    # alb.ingress.kubernetes.io/certificate-arn: "arn:aws:acm:us-west-2:123456789012:certificate/your-cert-id"  # Add your ACM certificate ARN for HTTPS
    # alb.ingress.kubernetes.io/security-groups: "sg-xxxxxxxxx"  # Add your security group if needed
  hosts:
    - paths:
        - path: /
          pathType: Prefix

# Production ConfigMap
configMap:
  enabled: true
  data:
    app.properties: |
      # Production configuration
      server.port=8080
      logging.level.root=INFO
      management.endpoints.web.exposure.include=health,info,metrics
      spring.profiles.active=production

# Enable persistence in production
persistence:
  enabled: true
  storageClass: "gp3"
  accessMode: ReadWriteOnce
  size: 20Gi
  mountPath: /app/data

# Strict probes for production
livenessProbe:
  enabled: true
  httpGet:
    path: /health
    port: http
  initialDelaySeconds: 30
  periodSeconds: 10
  timeoutSeconds: 5
  failureThreshold: 3

readinessProbe:
  enabled: true
  httpGet:
    path: /ready
    port: http
  initialDelaySeconds: 5
  periodSeconds: 5
  timeoutSeconds: 3
  failureThreshold: 3

# Enable Pod Disruption Budget
podDisruptionBudget:
  enabled: true
  minAvailable: 2

# Production security context
securityContext:
  runAsNonRoot: true
  runAsUser: 1000
  runAsGroup: 3000
  fsGroup: 2000
  allowPrivilegeEscalation: false
  readOnlyRootFilesystem: true
  capabilities:
    drop:
      - ALL

# Production affinity for better distribution
affinity:
  podAntiAffinity:
    preferredDuringSchedulingIgnoredDuringExecution:
      - weight: 100
        podAffinityTerm:
          labelSelector:
            matchExpressions:
              - key: app.kubernetes.io/name
                operator: In
                values:
                  - my-app
          topologyKey: kubernetes.io/hostname

================================================================================
16. GITHUB ACTIONS CI/CD PIPELINE
================================================================================

# .github/workflows/deploy.yml
name: Build and Deploy to EKS

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

env:
  AWS_REGION: ap-south-1
  ECR_REPOSITORY: code_dev
  EKS_CLUSTER_NAME: my-cluster

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    - name: Build, tag, and push image to Amazon ECR
      id: build-image
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        IMAGE_TAG: ${{ github.sha }}
      run: |
        # Build a docker container and push it to ECR
        docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG

        # Also tag as latest for convenience
        docker tag $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG $ECR_REGISTRY/$ECR_REPOSITORY:latest
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest

        echo "image=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG" >> $GITHUB_OUTPUT

    - name: Install kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: 'v1.28.0'

    - name: Install Helm
      uses: azure/setup-helm@v3
      with:
        version: '3.12.0'

    - name: Update kube config
      run: aws eks update-kubeconfig --name $EKS_CLUSTER_NAME --region $AWS_REGION

    - name: Deploy to Development
      if: github.ref == 'refs/heads/develop'
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        IMAGE_TAG: ${{ github.sha }}
      run: |
        cd helm
        helm upgrade --install my-app ./my-app \
          --namespace code-dev \
          --create-namespace \
          --values ./my-app/values.yaml \
          --set image.registry=$ECR_REGISTRY \
          --set image.tag=$IMAGE_TAG \
          --wait --timeout=10m

    - name: Deploy to Production
      if: github.ref == 'refs/heads/main'
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        IMAGE_TAG: ${{ github.sha }}
      run: |
        cd helm
        helm upgrade --install my-app ./my-app \
          --namespace code-dev \
          --create-namespace \
          --values ./my-app/values-prod.yaml \
          --set image.registry=$ECR_REGISTRY \
          --set image.tag=$IMAGE_TAG \
          --wait --timeout=10m

    - name: Get Application URL
      if: success()
      run: |
        echo "Waiting for ALB to be ready..."
        sleep 60

        ALB_URL=$(kubectl get ingress -n code-dev -o jsonpath='{.items[0].status.loadBalancer.ingress[0].hostname}' 2>/dev/null || echo "ALB still provisioning")

        echo "🚀 Deployment completed successfully!"
        echo "📱 Application URL: http://$ALB_URL"
        echo "🔍 Check deployment status: kubectl get pods -n code-dev"

        # Add URL to job summary
        echo "## 🚀 Deployment Summary" >> $GITHUB_STEP_SUMMARY
        echo "- **Environment**: $(if [ '${{ github.ref }}' = 'refs/heads/main' ]; then echo 'Production'; else echo 'Development'; fi)" >> $GITHUB_STEP_SUMMARY
        echo "- **Image**: ${{ steps.build-image.outputs.image }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Application URL**: http://$ALB_URL" >> $GITHUB_STEP_SUMMARY
        echo "- **Namespace**: code-dev" >> $GITHUB_STEP_SUMMARY

================================================================================
17. DEPLOYMENT COMMANDS
================================================================================

# Quick deployment commands:

# Deploy to development:
helm upgrade --install my-app ./helm/my-app \
  --namespace code-dev \
  --create-namespace \
  --values ./helm/my-app/values.yaml

# Deploy to production (with production overrides):
helm upgrade --install my-app ./helm/my-app \
  --namespace code-dev-prod \
  --create-namespace \
  --values ./helm/my-app/values.yaml \
  --set replicaCount=3 \
  --set env[0].value="production"

# Get application URL:
kubectl get ingress -n code-dev -o jsonpath='{.items[0].status.loadBalancer.ingress[0].hostname}'

# Check deployment status:
kubectl get pods -n code-dev
kubectl get svc -n code-dev
kubectl get ingress -n code-dev

# View logs:
kubectl logs -l app.kubernetes.io/name=my-app -n code-dev

# Scale application:
kubectl scale deployment my-app --replicas=5 -n code-dev

================================================================================
18. USAGE INSTRUCTIONS
================================================================================

1. **Setup Requirements:**
   - AWS EKS cluster with AWS Load Balancer Controller installed
   - ECR repository created (code_dev)
   - GitHub repository with secrets configured:
     - AWS_ACCESS_KEY_ID
     - AWS_SECRET_ACCESS_KEY

2. **Directory Structure:**
   ```
   your-project/
   ├── .github/workflows/deploy.yml
   ├── helm/my-app/
   │   ├── Chart.yaml
   │   ├── values.yaml
   │   ├── values-dev.yaml
   │   ├── values-prod.yaml
   │   └── templates/
   │       ├── _helpers.tpl
   │       ├── deployment.yaml
   │       ├── service.yaml
   │       ├── ingress.yaml
   │       ├── configmap.yaml
   │       ├── secret.yaml
   │       ├── serviceaccount.yaml
   │       ├── hpa.yaml
   │       ├── pdb.yaml
   │       ├── pvc.yaml
   │       ├── networkpolicy.yaml
   │       └── NOTES.txt
   └── Dockerfile
   ```

3. **Customization:**
   - Update ECR registry URL in values files
   - Modify environment variables as needed
   - Adjust resource limits based on your application
   - Configure SSL certificates if needed
   - Update health check paths for your application

4. **Features Included:**
   - Auto-scaling (HPA)
   - Pod disruption budgets
   - Security contexts
   - Persistent storage (optional)
   - Network policies (optional)
   - ConfigMaps and Secrets
   - AWS ALB integration
   - Multi-environment support (dev/prod)
   - GitHub Actions CI/CD pipeline

================================================================================
END OF HELM CHART CODE
================================================================================
  rules:
    {{- range .Values.ingress.hosts }}
    - {{- if .host }}
      host: {{ .host | quote }}
      {{- end }}
      http:
        paths:
          {{- range .paths }}
          - path: {{ .path }}
            {{- if .pathType }}
            pathType: {{ .pathType }}
            {{- end }}
            backend:
              service:
                name: {{ include "my-app.fullname" $ }}
                port:
                  number: {{ $.Values.service.port }}
          {{- end }}
    {{- end }}
{{- end }}
